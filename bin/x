#!/usr/bin/env bash
#
# =====================================================================
#  Universal Archive Extractor (x)
# =====================================================================
#
#  A powerful, intelligent archive extraction utility that uses 7-Zip
#  to handle multiple archive formats with smart extraction logic.
#
#  Features:
#   • Multi-format support: Automatically handles zip, rar, 7z, tar, gz, tgz,
#     bz2, tbz, tbz2, xz, lzma, iso, cab, wim, arj, z and more.
#   • Auto-detects and uses available 7-Zip binary (7z or 7zz).
#   • Smart extraction logic:
#     - Single directory → extracted as-is
#     - Single file → placed directly in the target directory
#     - Multiple items → organized into an archive-named folder
#   • Pre-extraction file checking:
#     - Skips extraction if destination folder already exists
#     - Detects single-file archives and skips if the file already exists
#   • Optional -d / --delete flag to remove archives after successful extraction
#   • Safe operation with temporary extraction directories:
#     - Creates .<name>.extracting_tmp for safe extraction
#     - Automatically cleans up temp files on completion or interrupt
#   • Robust handling of special filenames (spaces, unicode, punctuation)
#   • Graceful interruption handling (Ctrl-C cleans up temporary files)
#
#  Usage:
#       x                # Extract all archives in current directory
#       x dir            # Extract all archives in specified directory
#       x file.zip       # Extract a single archive file
#       x file1.zip file2.rar   # Extract multiple specified files
#       x -d             # Extract all archives in current dir and delete them
#       x -d dir         # Extract and delete archives in specified directory
#       x -d file.zip    # Extract and delete a single archive
#
#  Requirements:
#   • 7-Zip command-line tool (7z or 7zz) must be installed and in PATH
#   • Bash shell environment
#
#  License: MIT
# =====================================================================

set -euo pipefail
shopt -s nullglob

########################################
# Detect 7z binary (7z or 7zz)
########################################

if command -v 7z >/dev/null 2>&1; then
  SEVENZIP="7z"
elif command -v 7zz >/dev/null 2>&1; then
  SEVENZIP="7zz"
else
  echo "Error: Neither '7z' nor '7zz' found in PATH." >&2
  exit 1
fi

########################################
# Supported extensions
########################################

SUPPORTED_EXTS=(
  zip rar 7z tar gz tgz bz2 tbz tbz2 xz lzma iso cab wim arj z
)

########################################
# State (for Ctrl-C cleanup)
########################################

CURRENT_TMP_DIR=""

########################################
# Helpers
########################################

can_extract() {
  local f="$1"
  local ext="${f##*.}"
  ext="${ext,,}"
  for e in "${SUPPORTED_EXTS[@]}"; do
    [[ "$e" == "$ext" ]] && return 0
  done
  return 1
}

# Check if archive contains a single file and if it already exists
check_single_file() {
  local file="$1"
  local dir="$(dirname "$file")"
  
  # Get list of files in archive (just the filenames)
  # Use -slt for detailed listing to get proper path information
  local file_list="$($SEVENZIP l -slt "$file" 2>/dev/null)"
  if [[ $? -ne 0 ]]; then
    return 1  # Not a valid archive or can't list contents
  fi
  
  # Count number of files (lines with "Path = " but not ending with / and not the archive itself)
  local archive_name="$(basename "$file")"
  local file_count=$(echo "$file_list" | grep "^Path = " | grep -v "/$" | grep -v "^Path = $archive_name$" | wc -l)
  
  # If exactly one file
  if [[ "$file_count" -eq 1 ]]; then
    # Extract the filename - make sure to exclude the archive itself here too
    local filename=$(echo "$file_list" | grep "^Path = " | grep -v "/$" | grep -v "^Path = $archive_name$" | cut -d'=' -f2- | xargs)
    
    # Check if the file already exists in the destination directory
    if [[ -f "$dir/$filename" ]]; then
      echo "$dir/$filename"  # Return the existing file path
      return 0
    fi
  fi
  
  return 1  # Not a single file or file doesn't exist
}

on_interrupt() {
  echo "CTRL-C pressed, aborting…" >&2

  if [[ -n "$CURRENT_TMP_DIR" && -d "$CURRENT_TMP_DIR" ]]; then
    echo "Cleaning temporary directory: $CURRENT_TMP_DIR" >&2
    cleanup_tmp_dir
  fi

  exit 1
}

########################################
# Extraction Logic
########################################

extract_file() {
  local file="$1"

  # Show file is being considered in verbose mode
  [[ "$VERBOSE" == "1" ]] && echo "Processing: $file"

  # Skip unsupported extension
  if ! can_extract "$file"; then
    [[ "$VERBOSE" == "1" ]] && echo "  Skipping (unsupported file format)"
    return
  fi

  local dir="$(dirname "$file")"
  local filename="$(basename "$file")"
  local base="${filename%.*}"
  local final_dir="$dir/$base"

  # Skip if already extracted to directory
  if [[ -d "$final_dir" ]]; then
    echo "Skipping $file (directory '$final_dir' already exists)"
    return
  fi
  
  # Check if this is a single file archive and if that file already exists
  local existing_file=$(check_single_file "$file")
  if [[ -n "$existing_file" ]]; then
    echo "Skipping $file (file '$existing_file' already exists)"
    return
  fi

  [[ "$VERBOSE" == "1" ]] && echo "  Extracting..."

  # Prepare per-file temp dir
  local tmp_dir="$dir/.${base}.extracting_tmp"
  CURRENT_TMP_DIR="$tmp_dir"

  rm -rf "$tmp_dir"
  mkdir -p "$tmp_dir"

  # Extract with interrupt trap
  trap on_interrupt INT

  # Set redirection based on verbose mode
  local redirection=""  # Default to no redirection (stdout)
  if [[ "$VERBOSE" != "1" ]]; then
    redirection=" >/dev/null"
  fi

  # Execute 7z with appropriate redirection
  if ! eval "\"$SEVENZIP\" x -y \"$file\" -o\"$tmp_dir\"$redirection"; then
    trap - INT
    echo "Extraction FAILED for: $file"
    cleanup_tmp_dir
    return
  fi

  trap - INT

  # List extracted items
  children=("$tmp_dir"/*)

  #
  # Case 1: Exactly one directory → unwrap directory
  #
  if ((${#children[@]} == 1)) && [[ -d "${children[0]}" ]]; then
    mv "${children[0]}" "$final_dir"
    cleanup_tmp_dir

    [[ "$DELETE_AFTER" == "1" ]] && rm -f "$file"
    echo "Extracted directory: $final_dir/"
    return
  fi

  #
  # Case 2: Exactly one file → put it next to archive
  #
  if ((${#children[@]} == 1)) && [[ -f "${children[0]}" ]]; then
    mv "${children[0]}" "$dir/"
    cleanup_tmp_dir

    [[ "$DELETE_AFTER" == "1" ]] && rm -f "$file"
    echo "Extracted file: $dir/$(basename "${children[0]}")"
    return
  fi

  #
  # Case 3: Multiple items → wrap in final_dir
  #
  mkdir -p "$final_dir"
  mv "$tmp_dir"/* "$final_dir"/
  cleanup_tmp_dir

  [[ "$DELETE_AFTER" == "1" ]] && rm -f "$file"
  echo "Extracted: $file → $final_dir/"
}

########################################
# Helper Functions
########################################

# Cleanup temporary directory
cleanup_tmp_dir() {
  if [[ -n "$CURRENT_TMP_DIR" && -d "$CURRENT_TMP_DIR" ]]; then
    rm -rf "$CURRENT_TMP_DIR" || true
    CURRENT_TMP_DIR=""
  fi
}

# Display usage information
display_help() {
  echo "Usage: $0 [options] [file1 file2 ... | directory]"
  echo ""
  echo "Options:"
  echo "  -d, --delete      Delete archives after successful extraction"
  echo "  -v, --verbose     Enable verbose output"
  echo "  -h, --help        Display this help message"
  echo ""
  echo "Examples:"
  echo "  $0                Extract all archives in current directory"
  echo "  $0 -d             Extract and delete all archives in current directory"
  echo "  $0 file.zip       Extract a single archive"
  echo "  $0 file1.zip file2.rar  Extract multiple archives"
  echo "  $0 /path/to/dir   Extract all archives in specified directory"
  echo ""
  exit 0
}

########################################
# Argument Handling
########################################

DELETE_AFTER=0
VERBOSE=0
input_files=()

while [[ $# -gt 0 ]]; do
  case "$1" in
  -d | --delete)
    DELETE_AFTER=1
    shift
    ;;
  -v | --verbose)
    VERBOSE=1
    shift
    ;;
  -h | --help)
    display_help
    ;;
  *)
    # Add to input files array
    input_files+=("$1")
    shift
    ;;
  esac
done

# If no input files specified, default to current directory
if [[ ${#input_files[@]} -eq 0 ]]; then
  input_files=(".")
fi

########################################
# Main
########################################

# Process each input item
for item in "${input_files[@]}"; do
  if [[ -d "$item" ]]; then
    # Process all files in directory
    if [[ "$VERBOSE" == "1" ]]; then
      echo "Scanning directory: $item"
    fi
    
    while IFS= read -r -d '' file; do
      extract_file "$file"
    done < <(find "$item" -maxdepth 1 -type f -print0)
  elif [[ -f "$item" ]]; then
    # Process single file
    extract_file "$item"
  else
    echo "Warning: $item is not a valid file or directory, skipping." >&2
  fi
done

# Final cleanup (ensure no temp directories remain)
cleanup_tmp_dir
